import escodegen from "escodegen";
import _ from "lodash";
import Promise from "bluebird";

import pluggable from "../pluggable";
import { CONTINUE } from "../pluggable";
import { constructBundle } from "./construct";
import compileModules from "./modules/compile";
import resolveModule from "./modules/resolve";
import hashBundle from "./bundles/hash";
import interpolateFilename from "./bundles/interpolate-filename";
import dedupeExplicit from "./bundles/dedupe-explicit";
import dedupeImplicit from "./bundles/dedupe-implicit";


export const bootstrapCompilation = pluggable(function bootstrapCompilation (opts) {
  return {
    cache: {
      modulesByAbsPath: Object.create(null)
    },
    opts: Object.freeze(opts)
  };
});

export const getModuleSeeds = pluggable(function getModuleSeeds () {
  return Promise.all(
    [].concat(_.keys(this.opts.entry), _.keys(this.opts.split))
      .map(relPath => this.resolveModule(relPath)
        .then(module => [relPath, module])
    ))
    .then(_.object);
}, { resolveModule });

export const getModuleMaps = pluggable(function getModuleMaps (moduleSeeds) {
  return this.compileModules(moduleSeeds)
    .then(modules => _.reduce(modules, (moduleMaps, module) => {
      moduleMaps.byHash[module.hash] = module;
      moduleMaps.byAbsPath[module.path] = module;
      return moduleMaps;
    }, {
      byHash: {},
      byAbsPath: {}
    }));
}, { compileModules });

export const initBundle = pluggable(function initBundle (bundleDef, module, isEntryPt) {
  return {
    module,
    dest: bundleDef.dest,
    isEntry: isEntryPt,
    includeRuntime: isEntryPt && !bundleDef.excludeRuntime
  };
});

export const getBundleSeeds = pluggable(function getBundleSeeds (moduleSeeds, modulesByPath) {
  return Promise.all([].concat(
    _.map(this.opts.entry, (bundleDef, relPath) =>
      this.initBundle(bundleDef, modulesByPath[moduleSeeds[relPath].path], true)),
    _.map(this.opts.split, (bundleDef, relPath) =>
      this.initBundle(bundleDef, modulesByPath[moduleSeeds[relPath].path], false))
  ));
}, { initBundle });

export const getBundles = pluggable(function getBundles (moduleSeeds, moduleMaps) {
  return this.getBundleSeeds(moduleSeeds, moduleMaps.byAbsPath)
    .then(seedBundles => this.dedupeExplicit(seedBundles, moduleMaps.byAbsPath))
    .then(this.dedupeImplicit)
    .then(bundles => bundles.map(bundle => Object.assign({}, bundle, {
      modules: bundle.moduleHashes.map(hash => moduleMaps.byHash[hash])
    })))
    .then(bundles => Promise.all(bundles.map(this.hashBundle)))
    .then(bundles => Promise.all(bundles.map(this.interpolateFilename)));
}, { getBundleSeeds, dedupeExplicit, dedupeImplicit, hashBundle, interpolateFilename });

export const getUrls = pluggable(function getUrls (bundles) {
  return bundles.reduce((urls, bundle) => {
    bundle.moduleHashes.forEach(hash => urls[hash] = bundle.dest);
    return urls;
  }, {});
});

export const emitRawBundles = pluggable(function emitRawBundles (bundlesArr, urls) {
  const format = this.opts.pretty === false ?
    {
      compact: true,
      newline: ""
    } : {
      indent: {
        style: "  ",
        adjustMultilineComment: true
      }
    };

  return Promise.all(bundlesArr.map(bundle =>
    this.constructBundle({
      modules: bundle.modules,
      includeRuntime: bundle.includeRuntime,
      urls: bundle.isEntry ? urls : null,
      entryModuleHash: bundle.isEntry && bundle.module && bundle.module.hash || null
    })
      .then(bundleAst => escodegen.generate(bundleAst, {
        format,
        sourceMap: !!this.opts.sourceMaps,
        sourceMapWithCode: true,
        comment: !!this.opts.includeComments
      }))
      .then(({ code, map }) => {
        const outputBundle = Object.assign({}, bundle, { raw: code });
        const mapDest = bundle.dest + ".map";
        return this.opts.sourceMaps === true ?
          [outputBundle, { raw: map, dest: mapDest }] :
          [outputBundle];
      })
  ))
    .then(_.flatten);
}, { constructBundle });

/**
 * Given a stream of bundles, reduces those bundles down into a promise that
 * resolves into a final compilation object.
 *
 * This compilation object will have three key/value pairs:
 *
 * - cache:    populated cache from the compilation
 * - bundles:  a mapping of destination paths to `raw` code
 * - opts:     the original options passed to the compilation)
 *
 * @param  {Stream} bundles   Bundles generated by [getBundles](#getbundles).
 *
 * @return {Promise}          Compilation object.
 */
export const buildOutput = pluggable(function buildOutput (bundles) {
  return this.getUrls(bundles)
    .then(urls => this.emitRawBundles(bundles, urls))
    .then(rawBundles => _.chain(rawBundles)
        .map(rawBundle => [rawBundle.dest, rawBundle])
        .object()
        .value())
    .then(bundlesByDest => ({
      bundles: bundlesByDest,
      opts: this.opts,
      cache: this.cache
    }));
}, { getUrls, emitRawBundles });

/**
 * Performs an end-to-end compilation.
 *
 * @return {Promise}  compilation      Resolves to the compilation output.
 */
const compile = pluggable(function compile () {
  return this.getModuleSeeds()
    .then(moduleSeeds => Promise.all([
      moduleSeeds,
      this.getModuleMaps(_.values(moduleSeeds))
    ]))
    .then(([moduleSeeds, moduleMaps]) => this.getBundles(moduleSeeds, moduleMaps))
    .then(this.buildOutput);
}, { getModuleSeeds, getModuleMaps, getBundles, buildOutput });

function addPluginsToContext (compilationContext) {
  compilationContext.__pluggables__ = { override: {}, transform: {} };
  const overrides = compilationContext.__pluggables__.override;
  const transforms = compilationContext.__pluggables__.transform;

  (compilationContext.opts.plugins || []).forEach(plugin => {
    function override (pluggableFnName, overrideFn) {
      overrides[pluggableFnName] = (overrides[pluggableFnName] || []).concat(overrideFn);
    }
    function transform (pluggableFnName, transformFn) {
      transforms[pluggableFnName] = (transforms[pluggableFnName] || []).concat(transformFn);
    }

    _.extend(override, { CONTINUE });
    plugin(override, transform);
  });
}

export default function (opts) {
  return bootstrapCompilation(opts)
    .then(compilationContext => {
      addPluginsToContext(compilationContext);
      return compile.call(compilationContext);
    });
}
