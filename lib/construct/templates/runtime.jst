function copyProps (dest /* sources... */) {
  var len = arguments.length;
  if (arguments.length < 2 || dest === null) { return dest; }
  Array.prototype.splice.call(arguments, 1).forEach(function (src) {
    Object.keys(src).forEach(function (key) { dest[key] = src[key]; });
  });
  return dest;
}

var r = window[<%= globalName %>] = window[<%= globalName %>] || {
  modules: {},
  urls: {},

  load: function (moduleSet) {
    Object.keys(moduleSet).forEach(function (moduleHash) {
      var loadedModule = moduleSet[moduleHash];
      var unloadedDeps = loadedModule.deps.reduce(function (unloaded, dependencyHash) {
        var dependency = r.modules[dependencyHash];
        if (!dependency || dependency.blocking) {
          unloaded.push(dependencyHash);
          r.request(dependencyHash, moduleHash);
        }
        return unloaded;
      }, []);

      var module = r.modules[moduleHash] = copyProps(r.modules[moduleHash] || {}, loadedModule);

      if (!!unloadedDeps.length) {
        module.unloadedDeps = unloadedDeps;
      } else {
        r.resolve(moduleHash);
      }
    });
  },

  request: function (moduleHash, blockedModuleHash) {
    var module = r.modules[moduleHash] = r.modules[modulesHash] || {};
    module.blocking = (module.blocking || []).concat(blockedModuleHash);
    if (!module.requested) {

      var head = document.getElementsByTagName("head")[0];
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.charset = "utf-8";
      script.async = true;
      script.src = r.getUrl(moduleHash);

      script.onload = script.onreadystatechange = function () {
        script.onload = script.onreadystatechange = null;
        head.removeChild(script);
        // UMD shim could go here --> if expected global module name is provided
      }

      head.appendChild(script);

      module.requested = true;
    }
  },

  getUrl: function (moduleHash) {
    var url = r.urls[moduleHash];
    return url;
  },

  registerUrls: function (urls) {
    copyProps(r.urls, urls);
  },

  resolve: function (moduleHash) {
    var module = r.modules[moduleHash];

    (module.blocking || []).forEach(function (blockedModuleHash) {
      var blockedModule = r.modules[blockedModuleHash];
      blockedModule.unloadedDeps = blockedModule.unloadedDeps.reduce(function (unloaded, dependencyHash) {
        if (dependencyHash !== moduleHash) {
          unloaded.push(dependencyHash);
        }
      }, [])
      if (!blockedModule.unloadedDeps.length) {
        r.resolve(blockedModule);
      }
    });

    module.blocking = null;
  },

  require: function (moduleHash) {
    var module = r.modules[moduleHash];
    if (module.exports) { return module.exports; }

    var moduleObj = { exports: {} };
    module.fn.call(null, r.require.bind(r), moduleObj, moduleObj.exports);
    return module.exports = moduleObj.exports;
  }
};
