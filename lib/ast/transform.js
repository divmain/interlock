import most from "most";

import { getTraversableAst } from "./traverse";
import { NODE, ARRAY } from "./types";

function updateObj (obj, key, val) {
  const u = {};
  u[key] = val;
  return Object.assign({}, obj, u);
}

function updateArr (arr, key, val) {
  const newArr = arr.slice();
  newArr[key] = val;
  return newArr;
}

function transformNode (tuple, transformer) {
  return Promise.resolve(tuple.type === NODE ? transformer(tuple) : tuple)
    .then(transformedNode => {
      const { node, key, parents } = transformedNode;
      if (node !== tuple.node) {
        transformedNode = getTraversableAst(node, key, parents);
      }
      return transformedNode;
    });
}

function transformBranch (tuple, transformer) {
  /* eslint-disable block-scoped-var */
  return Promise.all([tuple, transformAst(tuple, transformer)]);
  /* eslint-enable block-scoped-var */
}

function applyUpdates (node, type, childUpdates) {
  if (type === NODE) {
    return childUpdates
      .reduce((newObj, childTuple) => updateObj(newObj, childTuple.key, childTuple.node), node);
  } else if (type === ARRAY) {
    return childUpdates
      .reduce((newArr, childTuple) => updateArr(newArr, childTuple.key, childTuple.node), node);
  }
  return Promise.resolve(node);
}

/**
 * Takes traversable AST node (as generated by `lib/ast/traverse`) and transforms
 * that node and all child nodes, passing each to the supplied transformer.  Any branches
 * modified or removed by a modification to its root node will not be traversed, and
 * the new branch will be traversed and transformed instead.
 *
 * @param   {Object}   nodeTuple   Tranversable node tuple, as generated by `getTraversableAst`.
 * @param   {Function} transformer Function to transform nodes.
 *
 * @returns {Promise}              Promise of transformed node (w/ transformed children).
 */
export default function transformAst (nodeTuple, transformer) {
  return transformNode(nodeTuple, transformer).then(transformedNode => {
    const { node, type, children } = transformedNode;

    const childUpdates = children
      .map(childTuple => transformBranch(childTuple, transformer))
      // TODO: identify why most.await is broke ¯\_(ツ)_/¯
      .flatMap(most.fromPromise)
      // .await()
      .filter(([childTuple, transformedChildNode]) => childTuple.node !== transformedChildNode)
      .map(([childTuple, transformedChildNode]) => Object.assign({}, childTuple, {
        node: transformedChildNode
      }));

    return applyUpdates(node, type, childUpdates);
  });
}
